# import standard libraries
import os
import sys
import numpy as np

# add psspy to the path
sys.path.append(r"C:\Program Files (x86)\PTI\PSSEXplore34\PSSBIN")
os.environ['PATH'] = (r"C:\Program Files (x86)\PTI\PSSEXplore34\PSSBIN;" + os.environ['PATH'])
sys.path.append(r"C:\Program Files (x86)\PTI\PSSEXplore34\PSSPY27")
os.environ['PATH'] = (r"C:\Program Files (x86)\PTI\PSSEXplore34\PSSPY27;" + os.environ['PATH'])
sys.path.append(r"C:\Program Files (x86)\PTI\PSSEXplore34\PSSPY34")
os.environ['PATH'] = (r"C:\Program Files (x86)\PTI\PSSEXplore34\PSSPY34;" + os.environ['PATH'])

# imported libraries for psse
import psspy, pssarrays
from psspy import _i
from psspy import _f
import redirect

redirect.psse2py()

######################################################
# Base parameters and constants
######################################################
# BASE_MVA = 100  # set as wanted in MVA
TOIS = 1  # Take only in service
TIWP = 2  # take in working plants
TWBT = 3  # take working branches & transformers
debug = False
mega_solving = True  # Add solves to make sure that the output is correct (makes the script slower)


######################################################


######################################################
# Functions Definitions
######################################################

# ##########################################
# easy input functions
# ##########################################


def update_one_load(bus_num, P_new, Q_new):
    """
    Update the parameters of a load in the system
    Can only handle one load at a bus
    -----------------------------------------------------
    :param bus_num: Number of the updated load [integer]
    :param P_new: Active power used by the load [float]
    :param Q_new: Reactive power used by the load [float]
    """
    error_code = psspy.load_data_5(bus_num, '1', [_i, _i, _i, _i, _i, _i], [P_new, Q_new, _f, _f, _f, _f])
    # Case of and update error
    if error_code > 0:
        print("\nproblem changing load data, error code is = " + str(error_code))


def update_bus(bus_num, base_voltage, voltage_in_pu):
    """
    Update the parameters of a chosen bus
    -----------------------------------------------------
    :param bus_num: Number of the updated bus [integer]
    :param base_voltage: The bus's base voltage in Kvolts [float]
    :param voltage_in_pu: The bus's base voltage in whole system per-units [float]
    """
    error_code = psspy.bus_data_4(bus_num, 0, [_i, _i, _i, _i], [base_voltage, voltage_in_pu, _f, _f, _f, _f, _f])
    # Case of an update error
    if error_code > 0:
        print("\nproblem changing bus data, error code is = " + str(error_code))


def machine_on(machine_bus, machine_num, on):
    """
    Turn on a generator connected to a chosen bus
    -----------------------------------------------------
    :param machine_bus: Number of bus to which the generator is connected [integer]
    :param machine_num: Number of machine which represent the generator [integer]
    :param on: Is the generator on or off [boolean]
    """
    # Turning on the machine
    if on:
        error_code = psspy.machine_chng_2(machine_bus, str(machine_num), [1, _i, _i, _i, _i, _i],
                                          [_f, _f, _f, _f, _f, _f, _f, _f, _f, _f, _f, _f, _f, _f, _f, _f, _f])
    # Turning off the machine
    else:
        error_code = psspy.machine_chng_2(machine_bus, str(machine_num), [0, _i, _i, _i, _i, _i],
                                          [_f, _f, _f, _f, _f, _f, _f, _f, _f, _f, _f, _f, _f, _f, _f, _f, _f])
    # Case of an error
    if error_code > 0:
        print("\nproblem turning on\\off machine, error code is = " + str(error_code))


def update_machine_power(machine_bus, machine_num, P_new, PF):
    """
    Updates the power generated by the chosen generator
    -----------------------------------------------------
    :param machine_bus: Number of bus to which the generator is connected [integer]
    :param machine_num: Number of machine which represent the generator [integer]
    :param P_new: The updated active power of the generator in MW [float]
    :param PF: The updated power factor of the generator, PF <= 1 [float]
    """
    # Parameters definition
    if (PF > 1) and (PF < 1.0002):  # fixing numeric problem
        PF = 1
        if debug:
            print("\nPF was: " + str(PF) + ", fixed to 1")
    Q_new = P_new * np.sqrt(1/(PF * PF) - 1)
    MVA_base = P_new / PF
    # Updating the machine's power
    error_code = psspy.machine_data_2(machine_bus, str(machine_num), [_i, _i, _i, _i, _i, _i],
                                      [P_new, Q_new, Q_new, Q_new, _f, _f, MVA_base, _f, _f, _f, _f, _f, _f, _f, _f, _f,
                                       PF])
    # Case of an error
    if error_code > 0:
        print("\nproblem updating machine power, error code is = " + str(error_code))


def update_machine_impedance(machine_bus, machine_num, r_source, x_source):
    """
    Updates r_source and x_source for the chosen generator
    -----------------------------------------------------
    :param machine_bus: Number of bus to which the generator is connected [integer]
    :param machine_num: Number of machine which represent the generator [integer]
    :param r_source: the short-current resistance (short-current power)
    :param x_source: the short-current reactance
    """
    # Updating the machine impedance
    error_code = psspy.machine_chng_2(machine_bus, str(machine_num), [_i, _i, _i, _i, _i, _i],
                                      [_f, _f, _f, _f, _f, _f, _f, r_source, x_source, _f, _f, _f, _f, _f, _f, _f, _f])
    # Case of an error
    if error_code > 0:
        print("\nproblem updating machine impedance, error code is = " + str(error_code))


def load_change_by_percentage_from_base(buses_list, base_loads, PF, percentage):  # # Can only handle one load at a bus
    """
    Changes all the loads relatively to the base loads
    -----------------------------------------------------
    :param buses_list: list of buses with loads [int vector]
    :param base_loads: base loads of all loads in MVA (S) [float vector]
    :param PF: The power factor of all the loads, PF <= 1 [float]
    :param percentage: the percentage of the new loads compare to the old loads, in range of 0-100 [float]
    """
    factor = 0.01 * percentage
    # Updating the loads one by one
    for it in range(len(buses_list)):
        P_load = PF * base_loads[it] * factor
        Q_load = np.sqrt(1 - PF * PF) * base_loads[it] * factor
        update_one_load(buses_list[it], P_load, Q_load)


def load_change_by_percentage_from_current(PF, percentage):
    """
    Changes all the loads compare to current loads.
    Can only handle one load at a bus.
    Not in use at this time, kept for future use
    -----------------------------------------------------
    :param PF: The power factor of all the loads, PF <= 1 [float]
    :param percentage: the percentage of the new loads compare to the old loads, in range of 0-100 [float]
    """
    factor = 0.01 * percentage
    # Getting buses numbers
    error_code, [buses] = psspy.abusint(-1, TOIS, 'NUMBER')
    # Case of an error
    if error_code > 0:
        print("\nproblem getting buses info, error code is = " + str(error_code))

    # Getting buses types
    bus_num = len(buses)
    error_code, [bus_type_vector] = psspy.abusint(-1, TOIS, 'TYPE')
    # Case of an error
    if error_code > 0:
        print("\nproblem getting buses info, error code is = " + str(error_code))

    # Updating each bus, one by one
    for it in range(bus_num):
        # 2 = generator bus, 3 = slack bus, shouldn't be changed
        if bus_type_vector[it] == 2 or bus_type_vector[it] == 3:
            continue
        error_code, load = psspy.loddt1(buses[it], '1', 'TOTAL', 'NOM')
        # Case of an error while loading data
        if error_code > 0:
            print("\nproblem getting buses info, error code is = " + str(error_code))
        # Calculating parameters for the update
        P_load = PF * load * factor
        Q_load = np.sqrt(1 - PF * PF) * load * factor
        # Updating the load
        update_one_load(buses[it], P_load, Q_load)


def update_transformer_mva(from_bus, to_bus, brn_id, new_mva):
    """
    update the MVA of a transformer
    ---------------------------------------------------------------------
    :param from_bus: from bus of the transformer [int]
    :param to_bus: from bus of the transformer [int]
    :param brn_id: id of the transformer [str]
    :param new_mva: new MVA transformer [floats]
    """

    error_code, [NIU1, NIU2] = psspy.two_winding_chng_5(from_bus, to_bus, brn_id,
                                                        [_i, _i, _i, _i, _i, _i, _i, _i, _i, _i, _i, _i, _i, _i, _i],
                                                        [_f, _f, _f, _f, _f, _f, _f, _f, _f, _f, _f, _f, _f, _f, _f, _f,
                                                         _f, _f, _f, _f, _f],
                                                        [new_mva, _f, _f, _f, _f, _f, _f, _f, _f, _f, _f, _f])
    if error_code > 0:
        print("\nproblem setting transformer new MVA, error code is = " + str(error_code))


def update_gen_and_trans_together(gen_bus, gen_id, gen_new_P, gen_new_PF, trans_to_bus, trans_id):
    """
    Updates the power generated by the chosen generator and the MVA of a transformer
    ---------------------------------------------------------------------
    :param gen_bus: Number of bus to which the generator is connected [integer]
    :param gen_id: Number of machine which represent the generator [integer]
    :param gen_new_P: The updated active power of the generator in MW [float]
    :param gen_new_PF: The updated power factor of the generator, PF <= 1 [float]
    :param trans_to_bus: from bus of the transformer [int]
    :param trans_id: id of the transformer [str]
    """

    update_machine_power(gen_bus, str(gen_id), gen_new_P, gen_new_PF)
    inner_new_mva = gen_new_P / gen_new_PF
    update_transformer_mva(gen_bus, trans_to_bus, str(trans_id), inner_new_mva)
    return


def psse_verbose(on):
    """
    Prints PSSE output of the network
    ----------------------------------
    :param on: ON/OFF switch [boolean]
    """
    if on:
        psspy.report_output(1)
        psspy.progress_output(1)
        psspy.alert_output(1)
        psspy.prompt_output(1)
    else:
        psspy.report_output(6)
        psspy.progress_output(6)
        psspy.alert_output(6)
        psspy.prompt_output(6)


def seem_fnsl():
    """
    runs fnsl solving with wanted criteria
    ----------------------------------
    """
    error_code = psspy.fnsl([_i, _i, _i, _i, _i, 0, _i, _i])  # 1 for flat start
    if error_code > 0:
        print("\nproblem solving, error code is = " + str(error_code))


# next func jest for testing, to be removed
def seem_checks(text):
    print("\n" + str(text))

    print(gen_finder(True))
    error_code, [for_check] = psspy.aloadreal(-1, 4, 'TOTALACT')  # 4 - all loads
    if error_code > 0:
        print("\ncan't get loads MVA, error code is = " + str(error_code))
    print("MVA loads is : " + str(for_check))
    error_code, [for_check] = psspy.amachreal(-1, 4, 'PGEN')  # 4 - all loads
    if error_code > 0:
        print("\ncan't get loads MVA, error code is = " + str(error_code))
    print("P_gen : " + str(for_check))
    error_code, [for_check] = psspy.amachreal(-1, 4, 'QGEN')  # 4 - all loads
    if error_code > 0:
        print("\ncan't get loads MVA, error code is = " + str(error_code))
    print("Q_gen : " + str(for_check))
    error_code, [pretest_voltages] = psspy.abusreal(-1, TOIS, 'PU')
    print("voltages are: " + str(pretest_voltages))
    if error_code > 0:
        print("\nproblem getting pre_test voltages in PU info, error code is = " + str(error_code))
    error_code, [angles] = psspy.abusreal(-1, TOIS, "ANGLED")
    print("angles are: " + str(angles))
    if error_code > 0:
        print("\nproblem getting angles in degrees info, error code is = " + str(error_code))
    error_code, [MISMATCH] = psspy.abusreal(-1, TOIS, "MISMATCH")
    print("MISMATCH is: " + str(MISMATCH))
    if error_code > 0:
        print("\nproblem getting MISMATCH info, error code is = " + str(error_code))


# ##########################################
# data finding functions
# ##########################################

def get_transformer_to_bus(gen_bus):
    """
    Finds other end of a transformer connected to a bus
    :param gen_bus: the bus number in the gen side of the transformer [int]
    :return: the bus number of the network side of the transformer [int]
    """
    to_bus_of_transformer = 0
    # getting info about transformers in the case
    error_code, [to_buses] = psspy.atrnint(-1, 1, 3, TOIS, 2, 'TONUMBER')
    if error_code > 0:
        print("\nproblem getting transformers info, error code is = " + str(error_code))
    error_code, [from_buses] = psspy.atrnint(-1, 1, 3, TOIS, 2, 'FROMNUMBER')
    if error_code > 0:
        print("\nproblem getting transformers info, error code is = " + str(error_code))

    for index in range(len(from_buses)):
        if from_buses[index] == gen_bus:
            to_bus_of_transformer = to_buses[index]
    if not bool(to_bus_of_transformer):
        print("\nproblem finding to bus of transformer")
    return to_bus_of_transformer


def gen_finder(keep_swing=None):
    """
    Finding the buses that have generators connected to them and are not
    the swing bus and the generators ID and status
    note - finds only generators in in-service plants
    ------------------------------------------------------------------------
    :param keep_swing: if true, won't remove swing bus from list of gens [bool]
    :return Table of machines [numpy matrix, size num_of_gen X 3].
    Table of machines structure:
    Bus numbers | Bus ID | Generator status (ON / OFF)
    """

    # 1) get buses numbers
    # 2) Get generators IDs
    # 3) Get generators status
    # 4) removing non type 2 buses (like swing bus)

    # Get buses information
    error_code, [bus_numbers] = psspy.amachint(-1, TIWP, 'NUMBER')  # 2 - taking all machines in in-service plants
    # Case of an error
    if error_code > 0:
        print("\nproblem getting gen's info, error code is = " + str(error_code))
    bus_numbers = np.array(bus_numbers)

    # Get generators IDs
    error_code, [ID_numbers] = psspy.amachchar(-1, TIWP, 'ID')  # 2 - taking all machines in in-service plants
    # Case of an error
    if error_code > 0:
        print("\nproblem getting gen's info, error code is = " + str(error_code))
    ID_numbers = np.array(ID_numbers)

    # Get generators status
    error_code, [statuses] = psspy.amachint(-1, TIWP, 'STATUS')  # 2 - taking all machines in in-service plants
    # Case of an error
    if error_code > 0:
        print("\nproblem getting gen's info, error code is = " + str(error_code))
    statuses = np.array(statuses)

    # Creating the output table
    machine_table = np.concatenate((bus_numbers, ID_numbers, statuses))
    num_of_gen = len(machine_table) / 3
    machine_table = machine_table.reshape(3, num_of_gen)
    # Getting the generators types
    gens_already_checked = 0
    if not keep_swing:
        for it in range(num_of_gen):
            error_code, bus_type = psspy.busint(bus_numbers[it], 'TYPE')
            if error_code > 0:
                print("\nproblem getting bus's info, error code is = " + str(error_code))
            # Case bus type is not generator - Delete them from matrix
            if bus_type == 3:
                machine_table = np.delete(machine_table, gens_already_checked, 1)
                gens_already_checked = gens_already_checked - 1
            gens_already_checked = gens_already_checked + 1

    machine_table = np.transpose(machine_table)
    return machine_table


def swing_bus_finder():
    """
    Finding the bus with the swing generator
    -----------------------------------------
    :return bus number of swing bus [integer].
    """
    error_code, [buses_types] = psspy.abusint(-1, TOIS, 'TYPE')
    if error_code > 0:
        print("\nproblem getting buses types info, error code is = " + str(error_code))
    error_code, [buses_numbers] = psspy.abusint(-1, TOIS, 'NUMBER')
    if error_code > 0:
        print("\nproblem getting buses numbers, error code is = " + str(error_code))
    swing_bus_num = buses_numbers[buses_types.index(3)]
    return swing_bus_num


def find_free_machine_id():
    """
    finds a unused machine ID for the use of other functions
    Not in use at this time, kept for future use
    ---------------------------------------------------------
    :return free ID in a string format.
    """
    # Find all the existing machines
    error_code, [machine_ids] = psspy.amachchar(-1, 4, 'ID')  # 4 - taking all machines (working or not)
    # Case of an error
    if error_code > 0:
        print("\nproblem getting machines info, error code is = " + str(error_code))
    # Arranging the ids
    sorted_id_list = sorted(machine_ids)
    sorted_int_list = [int(i) for i in sorted_id_list]
    # Looking for a free id
    free_ids = [x for x in range(1, 100) if x not in sorted_int_list]  # The ID is in [1,99] according to the API
    # No free id was found
    if len(free_ids) == 0:
        print("Too many gen's and non free")
        return '-1'
    else:
        return str(free_ids[0])


def find_free_transformer_id():
    """
    finds an unused branch ID for the use of other functions
    -------------------------------------------------------
    :return free ID in a string format.
    """
    # Find all the existing machines
    error_code, [branch_ids] = psspy.abrnchar(-1, 1, 3, 4, 1, 'ID')  # 4 - all branches and transformers
    # Case of an error
    if error_code > 0:
        print("\nproblem getting branches info, error code is = " + str(error_code))
    # Arranging the ids
    sorted_id_list = sorted(branch_ids)
    sorted_int_list = [int(i) for i in sorted_id_list]
    # Looking for a free id
    free_ids = [x for x in range(1, 100) if x not in sorted_int_list]  # The ID is in (1,99] according to the API
    # No free id was found
    if len(free_ids) == 0:
        print("Too many branches and non free")
        return '-1'
    else:
        return str(free_ids[0])


def get_P_and_PF(gen_bus, gen_id):
    """
    finds the gen P and PF at current time.
    If the gen was off, will return 0 for both.
    -------------------------------------------------------
    :param gen_bus: Number of bus to which the generator is connected [integer]
    :param gen_id: Number of the generator [string]
    :return set of [P,PF] [floats].
    """

    error_code, current_P = psspy.macdat(gen_bus, str(gen_id), 'P')
    if error_code > 0 and not error_code == 4:
        print("\nproblem getting P info, error code is = " + str(error_code))
    if debug and error_code == 4:
        print("\ngen was off when checking for P")
    error_code, current_Q = psspy.macdat(gen_bus, str(gen_id), 'Q')
    if error_code > 0 and not error_code == 4:
        print("\nproblem getting Q info, error code is = " + str(error_code))
    if debug and error_code == 4:
        print("\ngen was off when checking for Q")
    current_PF = current_P / np.sqrt((current_P * current_P + current_Q * current_Q))  # fixed to be set by Q and not S

    return [current_P, current_PF]


# ##########################################
# parameters checking functions
# ##########################################


def check_lines_overload(print_on):
    """
    Checks for an overload on each of the lines
    -----------------------------------------------------
    :param print_on: Verbose for the function [boolean]
    :return check_output : The lines where there's an overload, and the current [dictionary]
    """

    # 1) getting lines info
    # 1) getting lines info
    # 2) Creating a table of lines to avoid double checking
    # 3) for each line
    # 3.1) get load as PU power S
    # 3.2) check for OL by S
    # 3.3) saving lines with problems in the output dictionary
    # 4) return a dictionary with lines with problems, empty if no problems.

    check_output = {}
    # checking for overloads on lines
    error_code, [from_table] = psspy.abrnint(-1, 1, 3, 1, 1, "FROMNUMBER")  # only non transformer, in service lines
    # Case of an error
    if error_code > 0:
        print("\nproblem getting lines info, error code is = " + str(error_code))
    error_code, [to_table] = psspy.abrnint(-1, 1, 3, 1, 1, "TONUMBER")  # only non transformer, in service lines
    if error_code > 0:
        print("\nproblem getting lines info, error code is = " + str(error_code))
    # Creating a table of links
    for line in range(len(from_table)):
        if to_table[line] < from_table[line]:
            to_table[line] = 0
            from_table[line] = 0
    to_table = [i for i in to_table if i != 0]
    from_table = [i for i in from_table if i != 0]

    # Creating the output matrices for the checkup
    overload = False
    percentage_on_lines_vec = np.zeros(len(from_table))
    currents_on_lines_vec = np.zeros(len(from_table))
    # Checking the lines for overload
    for it in range(len(from_table)):
        error_code, percentage_on_lines_vec[it] = psspy.brnmsc(from_table[it], to_table[it], "1", "PCTRTA")
        # Case of an error
        if error_code > 0:
            print("problem checking PU overload on lines, error code is = " + str(error_code))

        # Case of an overload
        if percentage_on_lines_vec[it] > 100:
            overload = True
            # Case of verbose
            if print_on and not debug:
                error_code, currents_on_lines_vec[it] = psspy.brnmsc(from_table[it], to_table[it], "1", "AMPS")
                # Case of an error
                if error_code > 0:
                    print("\nproblem getting lines info, error code is = " + str(error_code))
                print("\nline from bus " + str(from_table[it]) + " to bus " + str(to_table[it])
                      + " is overloaded, load percentage is "
                      + str("{:.2f}".format(percentage_on_lines_vec[it])) + "% \n"
                      + "the current on the line is " + str("{:.2f}".format(currents_on_lines_vec[it])) + "A")

            elif print_on and debug:
                print("\n lines overload")

            # Update the output dictionary with the error
            key = str(from_table[it]) + "_to_" + str(to_table[it])
            value = percentage_on_lines_vec[it]
            check_output[key] = value
    # Case of no lines overload
    if not overload:
        if print_on and not debug:
            print("\nNo Lines overload")

    return check_output


def check_voltage_change_2_5percent(original_voltage, new_voltage, verbose, bus_to_skip=None):
    """
    Checks that the new Voltage isn't bigger or smaller in more than 2.5 percent than the old voltage
    ----------------------------------------------------------------------------------------------------------
    :param original_voltage: The original voltage of the buses in volts [list of floats]
    :param new_voltage: New voltage of the buses in volts [list of floats]
    :param verbose: Print the checkup output [boolean]
    :param bus_to_skip: skip checking a single specific bus, used to skip the generator bus [int, default is None]
    :return: check_output: The buses that their voltage changed too much, and the percentage of change [dictionary]
    """

    # 1) get buses numbers
    # 2) for each bus (unless told to skip):
    # 2.1) calculate change in %
    # 2.2) if more then 2.5%, saves the results in dictionary
    # 3) returns the dictionary

    check_output = {}
    error_code, [buses] = psspy.abusint(-1, TOIS, 'NUMBER')
    # Case of an error
    if error_code > 0:
        print("\nproblem getting buses info, error code is = " + str(error_code))
    num_of_buses = len(original_voltage)
    # Checking all the buses for change, one by one
    for it in range(num_of_buses):
        if buses[it] == bus_to_skip:
            continue
        vol_change_in_per = (new_voltage[it] - original_voltage[it]) / original_voltage[it]
        # Case of a limit crossing and verbose
        if abs(vol_change_in_per) > 0.025:
            check_output[str(buses[it])] = (100 * vol_change_in_per)
            # Print output in case of verbose
            if verbose or debug:
                print("\nVoltage change in bus " + str(buses[it]) + " is " +
                      "{:.2f}".format(100 * vol_change_in_per) + "%, out of range")

    return check_output


def check_voltage_out_of_lim(voltage_vec, verbose):
    """
    Check if the voltage change in each bus doesn't cross the 10% bar from nominal
    -------------------------------------------------------------------
    :param voltage_vec: The rate of the voltages relatively to the original [list of floats]
    :param verbose: Print the checkup output [boolean]
    :return: check_output: The buses where the voltages cross the 10% boundary [dictionary]
    """
    check_output = {}
    error_code, [buses] = psspy.abusint(-1, TOIS, 'NUMBER')
    # Case of error
    if error_code > 0:
        print("\nproblem getting buses info, error code is = " + str(error_code))

    # Checking the buses one by one
    num_of_buses = len(voltage_vec)
    for it in range(num_of_buses):
        # Case of more than 10% change
        if voltage_vec[it] > 1.1 or voltage_vec[it] < 0.9:
            check_output[str(buses[it])] = voltage_vec[it]
            if verbose or debug:
                print("\nVoltage in bus " + str(buses[it]) + " is " +
                      "{:.2f}".format(voltage_vec[it]) + " in PU, out of range")

    return check_output


def check_voltage_for_gen_adding(gen_bus, gen_num, original_voltage, verbose):
    """
    Run all the relevant voltage checks for a chosen generator, runs as part of valid_P_and_PF_comb
    -------------------------------------------------------------------
    :param gen_bus: Number of bus to which the generator is connected [integer]
    :param gen_num: Number of the generator [integer]
    :param original_voltage: The original voltage of the buses before adding the generator in volts [list of floats]
    :param verbose: Print the checkup output [boolean]
    :return: False if all the voltages checks passed without errors [boolean]
    """

    # 1) makes sure machine is on
    # 2) run fnsl
    # 3) get current voltages
    # 4) run 2.5% check
    # 5) run out of lim check
    # 6) returns True if the is a problem

    machine_on(gen_bus, gen_num, True)
    error_code = psspy.fnsl()
    if error_code > 0:
        print("\nproblem solving, error code is = " + str(error_code))

    error_code, [new_voltage] = psspy.abusreal(-1, TOIS, 'PU')
    # Case of info extraction error
    if error_code > 0:
        print("\nproblem getting buses info, error code is = " + str(error_code))

    # Check for all the predetermined criterion
    check_2_5_per = check_voltage_change_2_5percent(original_voltage, new_voltage, verbose, gen_bus)
    check_limits = check_voltage_out_of_lim(new_voltage, verbose)

    # Printing errors if verbose
    if bool(check_2_5_per) and (verbose or debug):
        print("\nVoltage change more then 2.5%")

    if bool(check_limits) and (verbose or debug):
        print("\nVoltage is out of 10% range of nominal")

    return bool(check_2_5_per) or bool(check_limits)


def valid_P_and_PF_comb(P_gen, gen_bus, gen_id, pretest_voltages, verbose, chosen_PF, check_SCC_SCR):
    """
    Checks if a combination of P and PF for a certain generator is valid.
    The system and generator info needs to be updated before the function.
    ---------------------------------------------------------------------
    :param P_gen: The active power of the generator [float]
    :param gen_bus: bus of the checked bus
    :param gen_id: id of the checked bus
    :param pretest_voltages: A list of system voltages when the generator to be check is off [list of floats]
    :param verbose: Print the checkup output [boolean]
    :param chosen_PF: The chosen PF to check [float]
    :return: The combination is valid [boolean]
    """

    # 1)Make sure the test generator is on
    # 2) run check_voltage_for_gen_adding
    # 3) run check_SCC
    # 4) run check_SCR
    # 5) run lines_overload
    # 6) returns true if comb is valid

    # Parameters
    valid_comb = True

    # Make sure the test generator is on
    machine_on(gen_bus, gen_id, True)

    if mega_solving:
        seem_fnsl()

    # Check that the criterion are met

    invalid_voltage = check_voltage_for_gen_adding(gen_bus, gen_id, pretest_voltages, verbose)
    if invalid_voltage:
        valid_comb = False

    if valid_comb:
        if check_SCC_SCR:
            check_scc = check_SCC(gen_bus, gen_id, verbose)
            if check_scc:
                valid_comb = False

    if valid_comb:
        if check_SCC_SCR:
            check_scr = check_SCR(gen_bus, gen_id, verbose)
            if check_scr:
                valid_comb = False

    if valid_comb:
        lines_overload = check_lines_overload(verbose)
        if bool(lines_overload):
            valid_comb = False

    if verbose and valid_comb:
        print("\n - Valid - for Gen " + str(gen_id) + " with P which is "
              + str(P_gen) + "MW"
              + " with PF of: " + str(chosen_PF)
              + " at bus: " + str(gen_bus))

    elif verbose and not valid_comb:
        print("\n -  Not Valid - for Gen " + str(gen_id) + " with P which is "
              + str(P_gen) + "MW"
              + " with PF of: " + str(chosen_PF)
              + " at gen bus: " + str(gen_bus))

    return valid_comb


def find_minimal_PF_for_gen(gen_bus, gen_num, P_gen, original_voltages, verbose,
                            trans_to_bus, trans_id, check_SCC_SCR):
    """
    Finding the minimal PF that the network allows in the range [0.9, 1)
    ------------------------------------------------------------------------
    :param gen_bus: Number of bus to which the generator is connected [integer]
    :param gen_num: Number of the generator [integer]
    :param P_gen: The active power supplied by the generator [float]
    :param original_voltages: The voltages before running using the chosen generator [list of floats]
    :param verbose: Print the checkup output [boolean]
    :param trans_to_bus: from bus of the transformer [int]
    :param trans_id: id of the transformer [str]
    :return: minimal_PF : The minimal PF that the network allows [float]
    """

    # 1) getting origin gen info
    # 2) for each PF from 1 to 0.9
    # 2.1) update machine and trans
    # 2.2) check valid comb
    # 2.3) if valid, update smallest_PF_found
    # 3) if found any valid, return the smallest. else return 0
    # 3) setting gen to origin state

    # Parameters definition
    PF_step = 0.01
    min_PF = 0.9
    smallest_PF_found = 1.1
    found_one = False

    # getting origin P and PF of gen
    [origin_P, origin_PF] = get_P_and_PF(gen_bus, str(gen_num))
    if verbose:
        print("\nfinding minimal PF for Gen " + str(gen_num) + " in bus " + str(gen_bus) +
              " while connected to bus " + str(trans_to_bus) + " with P of " + str(P_gen))

    # Trying different PF from 1 to 0.9
    for it in range(int((1 - min_PF) / PF_step) + 2):  # changed to 2 from 1 as seemed to skip 0.9
        PF_checking_now = 1 - PF_step * it
        update_gen_and_trans_together(gen_bus, str(gen_num), P_gen, PF_checking_now, trans_to_bus, trans_id)

        if mega_solving:
            seem_fnsl()

        # Check if the new system meet the criterion
        valid_comb = valid_P_and_PF_comb(P_gen, gen_bus, str(gen_num), original_voltages, verbose,
                                         PF_checking_now, check_SCC_SCR)
        if valid_comb:
            found_one = True
            smallest_PF_found = PF_checking_now

    # Case of a criterion mismatch for a certain PF
    if not found_one:
        # In case the generator can't be added
        if verbose or debug:
            print("\nGen " + str(gen_num) + " can not be added with given P " + str(P_gen) + " at bus "
                  + str(trans_to_bus))
        minimal_PF = 0
    else:
        # In case the generator can be added
        minimal_PF = smallest_PF_found
        if verbose or debug:
            print("\nsmallest working PF is " + str(minimal_PF))

    # Changing back to origin P and PF
    update_gen_and_trans_together(gen_bus, str(gen_num), origin_P, origin_PF, trans_to_bus, trans_id)

    if mega_solving:
        seem_fnsl()

    return minimal_PF


# ##########################################
# transformer needed functions
# ##########################################


def move_by_transformer(bus_numbers, new_bus, origin_connection_bus, origin_bus, old_to_bus, old_id_brn, free_id_brn,
                        last_is_origin, buses_to_skip=None):
    """
    move the transformer to a new "to bus" by certain rules
    ------------------------------------------------------------------------
    :param bus_numbers: table of buses to check at [list of int]
    :param new_bus: the number of the bus to which the transformer needs to be connected [int]
    :param origin_connection_bus: the number of the original "to bus" of the transformer [int]
    :param origin_bus: the number of the original "from bus" of the transformer (the gen bus) [int]
    :param old_to_bus: the number of the current "to bus" of the transformer [int]
    :param old_id_brn: the current id of the transformer [string]
    :param free_id_brn: the free id for the transformer if needed [string]
    :param last_is_origin: a flag to for outer function use [string]
    :param buses_to_skip: a list of buses the should be skipped [list of int, default is None]
    :return: a list of parameters for the use of outer function [list of [str,bool,int,bool]]
    """

    # 1) check new bus rules:
    # 1.1) if only 1 bus and is origin
    # 1.2) if last bus is origin bus
    # 1.3) if first bus is the origin connection bus
    # 1.4) if trying to connect both transformer sides to the gen bus
    # 1.5) if trying to connect the transformer to a different gen bus
    # 1.6) if checking for origin to_bus but not the last or first bus
    # 1.6) normal movement
    # 2) return parameters

    origin_id_brn = '1'
    continue_flag = False

    # take care of only 1 bus to check problems
    if len(bus_numbers) == 1 and new_bus == origin_connection_bus:
        # no need to move the gen, only change the id to run
        new_id_brn = str(origin_id_brn)
        last_is_origin = True
        new_to_bus = new_bus

    # take care of last bus is origin bus problems
    elif new_bus == origin_connection_bus and new_bus == bus_numbers[-1]:
        new_id_brn = str(origin_id_brn)
        last_is_origin = True
        error_code = psspy.movebrn(origin_bus, old_to_bus, old_id_brn, new_bus, origin_id_brn)
        if error_code > 0:
            print("\nproblem moving BRN, error code is = " + str(error_code))
        new_to_bus = new_bus

    # take care of first bus is origin to_bus of the transformer problems
    elif new_bus == origin_connection_bus and new_bus == bus_numbers[0]:
        # no need to move the gen, only change the id to run
        last_is_origin = True
        new_id_brn = str(origin_id_brn)
        new_to_bus = new_bus

    # trying to connect both transformer sides to the gen bus
    elif new_bus == origin_bus:
        if debug:
            print("\nskipping the generator bus which is " + str(new_bus))
        continue_flag = True
        new_to_bus = old_to_bus
        new_id_brn = old_id_brn

    # trying to connect the transformer to a different gen bus
    elif (buses_to_skip is not None) and str(new_bus) in buses_to_skip:
        if debug:
            print("\nskipping other gen's bus's, bus number is " + str(new_bus))
        continue_flag = True
        new_to_bus = old_to_bus
        new_id_brn = old_id_brn

    # checking for origin to_bus but not the last or first bus
    elif new_bus == origin_connection_bus:
        error_code = psspy.movebrn(origin_bus, old_to_bus, old_id_brn, new_bus, str(origin_id_brn))
        if error_code > 0:
            print("\nproblem moving BRN, error code is = " + str(error_code))
        if debug:
            print("\nfound origin to bus of gen, bus number is " + str(new_bus))
        last_is_origin = True
        new_to_bus = new_bus
        new_id_brn = str(origin_id_brn)

    # normal movement
    elif new_bus != origin_bus:
        error_code = psspy.movebrn(origin_bus, old_to_bus, old_id_brn, new_bus, free_id_brn)
        if error_code > 0:
            print("\nproblem moving BRN, error code is = " + str(error_code))
        last_is_origin = False
        new_to_bus = new_bus
        new_id_brn = free_id_brn

    else:
        print("\nproblem in move_by_transformer, no option was taken")
        new_to_bus = new_bus
        new_id_brn = free_id_brn

    return [str(new_id_brn), last_is_origin, new_to_bus, continue_flag]


# ##########################################
# short current functions
# ##########################################


def sc_current(verbose):
    """
    Return the Short circuit currents for all of the busses according to 3 phase fault check
    :param verbose: Print the checkup output [boolean]
    :return: The currents as a dictionary as described in the API for pssarrays.ascc_currents [dict]
    """
    psse_verbose(verbose)

    # Saving a tmp file to reverse the effect of psspy.flat
    # If the saving fails, try for "retries" more tries
    ierr = psspy.save('tmp')
    if ierr > 0:
        if debug:
            print("Saving 'tmp.sav' have failed for the first time with error code = " + str(ierr))
        retries = 3
        for retry in range(retries):
            ierr = psspy.save('tmp')
            if ierr > 0 and retry < retries - 1:
                if debug:
                    print("Saving 'tmp.sav' have for " + str(retries + 1) + " times with error code = " + str(ierr))
                break
            elif ierr > 0 and retry >= retries - 1:
                raise Exception("Error while saving 'tmp.sav' with error code= " + str(ierr) +
                                ". Tried for " + str(retries + 1) + " times.")
            else:
                break

    # Define relevant output's format
    error_code = psspy.short_circuit_coordinates(1)  # set output in polar coordinate
    if error_code > 0:
        raise Exception("Error while executing psspy.machine_data")

    error_code = psspy.short_circuit_units(1)  # set physical unit output
    if error_code > 0:
        raise Exception("Error while executing psspy.short_circuit_units(1)")
    error_code = psspy.newseq()  # set default sequence data to memory
    if error_code > 0:
        raise Exception("Error while executing psspy.newseq()")

    # Prepare the function to run
    error_code = psspy.flat([1, 1, 1, 1], [1.05, 0.0])  # option[1]=1-flat cl, option[1]=2-flat iec,
    if error_code > 0:
        raise Exception("Error while executing psspy.flat([1")
    error_code = psspy.flat([2, 1, 1, 1], [1.05, 0.0])  # option[2]=0-tap unchanged, option[2]=1-tap=1,
    if error_code > 0:
        raise Exception("Error while executing psspy.flat([2")

    # Get the fault currents
    currents = pssarrays.ascc_currents(sid=0, flt3ph=1)
    if currents.ierr > 0:
        raise Exception("Error while executing pssarrays.ascc_currents")

    # Loading the tmp file to  reverse the effect of psspy.flat
    ierr = psspy.case('tmp.sav')
    if ierr > 0:
        raise Exception("Error while loading 'tmp.sav' with error code= " + str(ierr))

    return currents


def check_SCC(gen_bus, gen_num, verbose):
    """
    :param gen_bus: Number of bus to which the generator is connected [integer]
    :param gen_num: Number of the generator [integer]
    :param verbose: Print the checkup output [boolean]
    :return: The generator doesn't meet the SCC limit
    """
    allowed_ratio = 25  # The maximal SCC by percentages
    # Get all the buses number - to analyze the results
    error_code, [busses] = psspy.abusint(-1, TOIS, 'NUMBER')
    # Case of an error
    if error_code > 0:
        print("\nproblem getting buses info, error code is = " + str(error_code))

    # currents with generator off
    machine_on(gen_bus, gen_num, False)

    if mega_solving:
        seem_fnsl()

    currents_without_gen = sc_current(verbose)

    # currents with generator on
    machine_on(gen_bus, gen_num, True)

    if mega_solving:
        seem_fnsl()

    currents_with_gen = sc_current(verbose)

    # export currents as a complex num
    bus_index = busses.index(get_transformer_to_bus(gen_bus))
    tmp_current_abs = currents_without_gen['flt3ph'][bus_index]['ia1'].real
    tmp_current_degree = np.radians(currents_without_gen['flt3ph'][bus_index]['ia1'].imag)
    system_current = tmp_current_abs * (np.cos(tmp_current_degree) + 1j * np.sin(tmp_current_degree))

    tmp_current_abs = currents_with_gen['flt3ph'][bus_index]['ia1'].real
    tmp_current_degree = np.radians(currents_with_gen['flt3ph'][bus_index]['ia1'].imag)

    # The Generator current is the SC current with the generator on minus the SC current with the generator off
    gen_current = (tmp_current_abs * (np.cos(tmp_current_degree) + 1j * np.sin(tmp_current_degree))) - system_current

    # Calculates the SCC parameter according to the third update. Assumes that the voltage is equal
    SCC = np.absolute(gen_current / system_current) * 100

    if debug and SCC >= allowed_ratio:
        print("\nSCC = " + str(SCC))

    if SCC >= allowed_ratio and (verbose or debug):
        print("\nSCC Value is bigger or equal to " + str(allowed_ratio) + "%")

    return SCC >= allowed_ratio


def check_SCR(gen_bus, gen_num, verbose):
    """
    :param gen_bus: Number of bus to which the generator is connected [integer]
    :param gen_num: Number of the generator [integer]
    :param verbose: Print the checkup output [boolean]
    :return: The generator doesn't meet the SCR limit
    """
    allowed_ratio = 8  # The maximal SCR by percentages

    error_code, [busses] = psspy.abusint(-1, TOIS, 'NUMBER')
    # Case of an error
    if error_code > 0:
        print("\nproblem getting buses info, error code is = " + str(error_code))

    # currents with generator off
    machine_on(gen_bus, gen_num, False)

    if mega_solving:
        seem_fnsl()

    currents_without_gen = sc_current(verbose)

    # export currents as a complex num

    error_code, BASE_V = psspy.busdat(get_transformer_to_bus(gen_bus), 'BASE')
    # Case of an error
    if error_code > 0:
        print("\nproblem getting BASE V info, error code is = " + str(error_code))

    bus_index = busses.index(get_transformer_to_bus(gen_bus))
    tmp_current_abs = currents_without_gen['flt3ph'][bus_index]['ia1'].real
    tmp_current_degree = np.radians(currents_without_gen['flt3ph'][bus_index]['ia1'].imag)
    system_current = tmp_current_abs * (np.cos(tmp_current_degree) + 1j * np.sin(tmp_current_degree))
    system_power = (np.absolute(system_current) * np.absolute(BASE_V * np.power(10, 3))) / np.power(10, 6)

    machine_on(gen_bus, gen_num, True)

    if mega_solving:
        seem_fnsl()

    error_code, gen_power = psspy.macdat(gen_bus, str(gen_num), 'P')
    if error_code > 0:
        print("problem getting gen_power info, error code is = " + str(error_code))
    error_code, gen_reactive_power = psspy.macdat(gen_bus, str(gen_num), 'Q')
    if error_code > 0:
        print("problem getting gen_reactive_power info, error code is = " + str(error_code))
    S_gen_sc = np.sqrt(np.power(gen_power, 2) + np.power(gen_reactive_power, 2))

    SCR = np.absolute(S_gen_sc / system_power) * 100

    if debug and SCR >= allowed_ratio:
        print("\nSCR = " + str(SCR))

    if SCR >= allowed_ratio and (verbose or debug):
        print("\nSCR Value is bigger or equal to " + str(allowed_ratio) + "%")

    return SCR >= allowed_ratio


# ##########################################
# main 3 functions
# ##########################################


def min_PF4P_1hour(P_gen, machines_in_use, pretest_voltages, verbose,
                   gen4testing, buses_to_check=None, check_SCC_SCR=True):
    """
    Finds the minimal PF per bus for a chosen active power
    :param P_gen: The maximal power to check [float]
    :param machines_in_use: An array of generators which are in use during the test [np.array]
    :param pretest_voltages: A list of system voltages when the generator to be check is off [list of floats]
    :param verbose: Print the checkup output [boolean]
    :param gen4testing: A parameter to find the chosen gen to use for checking [int]
    :param buses_to_check: List of buses to check the generator at. If None, check at all the buses [list of int,
                                                                                                    Default is None]
    :param check_SCC_SCR: Run SCC and SCR checks [Boolean]
    :return: output table format: (bus number, check number, 0=P of check / 1= PF res) [np.array]
    """

    # 1) getting machine and transformer origin info
    # 2) make sure machine is on - maybe not needed
    # 3) get the list of buses to check at
    # 4) for each bus to check at
    # 4.1) move the connect the transformer to the right place
    # 4.2) run find_minimal_PF_for_gen
    # 5) set results in output
    # 6) Setting all back to default case - place and P+PF

    # Parameters
    origin_id_brn = '1'
    free_id_brn = find_free_transformer_id()

    # Get generator parameters
    base_gen_info = machines_in_use[gen4testing, :]
    origin_bus = int(base_gen_info[0])
    origin_id = str(base_gen_info[1])
    machine_on(origin_bus, origin_id, True)

    if mega_solving:
        seem_fnsl()

    [origin_P, origin_PF] = get_P_and_PF(origin_bus, str(origin_id))

    # getting info about transformers in the case
    origin_connection_bus = get_transformer_to_bus(origin_bus)

    # Get buses to check at numbers
    if buses_to_check is not None:
        bus_numbers = list(buses_to_check)
    else:
        error_code, [bus_numbers] = psspy.abusint(-1, TOIS, 'NUMBER')
        if error_code > 0:
            print("problem getting buses info, error code is = " + str(error_code))

    # Set output and more parameters
    cols = 2
    output = np.zeros((len(bus_numbers), cols))
    # output table format: (bus number, check number, 0=P of check / 1= PF res)
    #                        | P | PF |

    # find minimal PF per bus
    new_to_bus = origin_connection_bus
    old_id_brn = origin_id_brn
    last_is_origin = False
    buses_to_skip_list = gen_finder(True)[:, 0]

    # move gen / transformer between buses
    for new_bus in bus_numbers:
        if debug:
            print("\nNow working on bus: " + str(new_bus))
        # move and find minimal PF
        [new_id_brn, last_is_origin, new_to_bus, continue_flag] = move_by_transformer(bus_numbers, new_bus,
                                                                                      origin_connection_bus,
                                                                                      origin_bus, new_to_bus,
                                                                                      old_id_brn, free_id_brn,
                                                                                      last_is_origin,
                                                                                      buses_to_skip_list)
        if continue_flag:
            continue

        old_id_brn = new_id_brn
        machine_on(origin_bus, origin_id, True)

        if mega_solving:
            seem_fnsl()

        minimal_PF = find_minimal_PF_for_gen(origin_bus, origin_id, P_gen, pretest_voltages, verbose,
                                             new_to_bus, str(old_id_brn), check_SCC_SCR)
        # set results in output
        output[bus_numbers.index(new_bus), 0] = P_gen
        output[bus_numbers.index(new_bus), 1] = minimal_PF

        if verbose or debug:
            if minimal_PF > 0:
                print("\nminimal working PF in bus " + str(new_to_bus) + " is " + str(minimal_PF)
                      + " with P of: " + str(P_gen) + "MW")

    # Setting all back to default case
    if verbose:
        print("\nSetting everything back to normal")

    if not last_is_origin:  # if not already in origin place, moving to there
        error_code = psspy.movebrn(origin_bus, new_to_bus, new_id_brn, origin_connection_bus, origin_id_brn)
        if error_code > 0:
            print("\ncan't move BRN back to place, error code is = " + str(error_code))

    update_gen_and_trans_together(origin_bus, str(origin_id), origin_P, origin_PF, origin_connection_bus, origin_id_brn)

    if mega_solving:
        seem_fnsl()

    if verbose or debug:
        print("\ngen " + str(origin_id) + " transformer is reconnected to original to_bus at bus "
              + str(origin_connection_bus))

    return output


def max_P4PF_1hour(max_p_to_check, machines_in_use, pretest_voltages, chosen_PF, verbose,
                   gen4testing, buses_to_check=None, check_SCC_SCR=True):
    """
    Finds the maximal active power per bus for a chosen PF
    ---------------------------------------------------------------------
    :param max_p_to_check: The maximal power to check [float]
    :param machines_in_use: An array of generators which are in use during the test [np.array]
    :param pretest_voltages: A list of system voltages when the generator to be check is off [list of floats]
    :param chosen_PF: The chosen PF to check [float]
    :param verbose: Print the checkup output [boolean]
    :param gen4testing: A parameter to find the chosen gen to use for checking [int]
    :param buses_to_check: List of buses to check. If None, check all the buses [list of int .Default is None]
    :param check_SCC_SCR: Run SCC and SCR checks [Boolean]
    :return: output table format: (bus number, check number, 0=P of check / 1= PF res) [np.array]
    """

    # 1) get origin info for gen and transformer
    # 2) for every bus in buses to check list
    # 2.1) moving the transformer to the right place
    # 2.2) finding maximal P be checking combos of the PF and different P. going P from max to min
    # 2.2.1) update machine P
    # 2.2.2) run valid_P_and_PF_comb
    # 2.2.3) if valid, saves the result in output. last check is for 0 P, so there is always a valid case
    # 3) Setting all back to default case

    # Parameters
    origin_id_brn = '1'
    P_step = 0.2  # as chosen by IEC
    free_id_brn = find_free_transformer_id()

    # Get generator parameters
    base_gen_info = machines_in_use[gen4testing, :]
    origin_bus = int(base_gen_info[0])
    origin_id = str(base_gen_info[1])
    machine_on(origin_bus, origin_id, True)

    if mega_solving:
        seem_fnsl()

    [origin_P, origin_PF] = get_P_and_PF(origin_bus, str(origin_id))

    # getting info about transformers in the case
    origin_connection_bus = get_transformer_to_bus(origin_bus)

    # Get buses to check at numbers
    if buses_to_check is not None:
        bus_numbers = list(buses_to_check)
    else:
        error_code, [bus_numbers] = psspy.abusint(-1, TOIS, 'NUMBER')
        if error_code > 0:
            print("problem getting buses info, error code is = " + str(error_code))

    # Set output and more parameters
    cols = 2
    output = np.zeros((len(bus_numbers), cols))
    # output table format: (bus number, check number, 0=P of check / 1= PF res)
    #                        | P | PF |
    new_to_bus = origin_connection_bus
    old_id_brn = origin_id_brn
    last_is_origin = False
    new_id_brn = free_id_brn
    buses_to_skip_list = gen_finder(True)[:, 0]

    for new_bus in bus_numbers:
        if debug:
            print("\nNow working on bus: " + str(new_bus))
        # move between buses
        [new_id_brn, last_is_origin, new_to_bus, continue_flag] = move_by_transformer(bus_numbers, new_bus,
                                                                                      origin_connection_bus,
                                                                                      origin_bus, new_to_bus,
                                                                                      old_id_brn, new_id_brn,
                                                                                      last_is_origin,
                                                                                      buses_to_skip_list)
        if continue_flag:
            continue

        old_id_brn = new_id_brn

        # finding maximal P be checking combos of the PF and different P. going P from max to min
        for it in range(int(max_p_to_check / P_step)):
            update_gen_and_trans_together(origin_bus, str(origin_id), max_p_to_check - P_step * it, chosen_PF,
                                          new_bus, str(old_id_brn))

            if mega_solving:
                seem_fnsl()

            comb_is_valid = valid_P_and_PF_comb(max_p_to_check - P_step * it, origin_bus, origin_id,
                                                pretest_voltages, verbose, chosen_PF, check_SCC_SCR)
            # Case of a Valid P
            if comb_is_valid:
                max_valid_p = max_p_to_check - P_step * it
                output[bus_numbers.index(new_bus), 0] = max_valid_p
                output[bus_numbers.index(new_bus), 1] = chosen_PF
                break
        if comb_is_valid:
            max_valid_p = max_p_to_check - P_step * it
            if verbose or debug:
                print("\nlast working P in bus " + str(new_bus) + " is " + str(max_valid_p) + "MW"
                      + " with PF of: " + str(chosen_PF))

    # Setting all back to default case
    if verbose:
        print("\nSetting everything back to normal")

    if not last_is_origin:  # if not already in origin place, moving to there
        error_code = psspy.movebrn(origin_bus, new_to_bus, new_id_brn, origin_connection_bus, origin_id_brn)
        if error_code > 0:
            print("\ncan't move BRN back to place, error code is = " + str(error_code))

    update_gen_and_trans_together(origin_bus, str(origin_id), origin_P, origin_PF, origin_connection_bus,
                                  str(origin_id_brn))

    if mega_solving:
        seem_fnsl()

    if verbose:
        print("\ngen " + str(origin_id) + " is back at bus " + str(origin_bus))

    return output


def each_P_min_PF(max_p_to_check, min_p_to_check, machines_in_use, pretest_voltages,
                  verbose, gen4testing, buses_to_check=None, check_SCC_SCR=True):
    """
    Finds the minimal PF for each active power within the range (0, max_p_max_p_to_check]
    -------------------------------------------------------------------------------------
    :param max_p_to_check: The maximal power to check [float]
    :param min_p_to_check: The minimal power to check [float]
    :param machines_in_use: An array of generators which are in use during the test [np.array]
    :param pretest_voltages: A list of system voltages when the generator to be check is off [list of floats]
    :param verbose: Print the checkup output [boolean]
    :param gen4testing: A parameter to find the chosen gen to use for checking [int]
    :param buses_to_check: List of buses to check. If None, check all the buses [list of int .Default is None]
    :param check_SCC_SCR: Run SCC and SCR checks [Boolean]
    :return: output table format: (bus number, check number, 0=P of check / 1= PF res) [np.array]
    """

    # 1) get origin info for gen and transformer
    # 2) for each bus in buses to check list:
    # 2.1) moving the transformer to the right place
    # 2.2) for each P in range set by user, going min to max:
    # 2.2.1) run find_minimal_PF_for_gen
    # 2.2.2) if non possible combo, break
    # 2.2.3) save results
    # 3) Setting all back to default case
    # 4) return output

    origin_id_brn = '1'
    # Parameters
    P_step = 0.2  # as chosen by IEC
    free_id_brn = find_free_transformer_id()

    # Get generator parameters
    base_gen_info = machines_in_use[gen4testing, :]
    origin_bus = int(base_gen_info[0])
    origin_id = int(base_gen_info[1])
    machine_on(origin_bus, origin_id, True)

    if mega_solving:
        seem_fnsl()

    [origin_P, origin_PF] = get_P_and_PF(origin_bus, str(origin_id))

    # getting info about transformers in the case
    origin_connection_bus = get_transformer_to_bus(origin_bus)

    # Get bus numbers
    if buses_to_check is not None:
        bus_numbers = list(buses_to_check)
    else:
        error_code, [bus_numbers] = psspy.abusint(-1, TOIS, 'NUMBER')
        if error_code > 0:
            print("problem getting buses info, error code is = " + str(error_code))

    # Set output
    rows = int((max_p_to_check - min_p_to_check) / P_step) + 1  # The +1 is to check the edges as well
    cols = 2
    output = np.zeros((len(bus_numbers), rows, cols))
    # output position's format: (bus number, check number, 0=P of check / 1= PF res)
    # output's format: | P | PF |

    # Find possible and maximal P for a given load
    new_to_bus = origin_connection_bus
    old_id_brn = origin_id_brn
    last_is_origin = False
    new_id_brn = free_id_brn
    buses_to_skip_list = gen_finder(True)[:, 0]
    for new_bus in bus_numbers:
        final_it = 0
        minimal_PF = 0
        print("\nCalculating for bus No. " + str(new_bus))
        [new_id_brn, last_is_origin, new_to_bus, continue_flag] = move_by_transformer(bus_numbers, new_bus,
                                                                                      origin_connection_bus,
                                                                                      origin_bus, new_to_bus,
                                                                                      old_id_brn, new_id_brn,
                                                                                      last_is_origin,
                                                                                      buses_to_skip_list)
        if continue_flag:
            continue

        old_id_brn = new_id_brn
        machine_on(origin_bus, origin_id, True)

        if mega_solving:
            seem_fnsl()

        found_working_P_in_bus = False

        # for each P in the range given by the user, going min to max
        for it in range(int((max_p_to_check - min_p_to_check) / P_step) + 1):

            minimal_PF = find_minimal_PF_for_gen(origin_bus, origin_id, min_p_to_check + (P_step * it),
                                                 pretest_voltages, verbose, new_bus, str(old_id_brn), check_SCC_SCR)

            if minimal_PF > 0:
                # saving results
                output[bus_numbers.index(new_bus), it, 0] = min_p_to_check + (P_step * it)
                output[bus_numbers.index(new_bus), it, 1] = minimal_PF
                found_working_P_in_bus = True

            else:
                final_it = it - 1
                break

        if not found_working_P_in_bus:
            print("\nnone working P, consider changing the minimal P value and run the program again")

        elif final_it == ((max_p_to_check - min_p_to_check) / P_step) + 1:
            if verbose or debug:
                print("\nGen can be added with max P which is "
                      + str(max_p_to_check) + "MW"
                      + "with PF of: " + str(minimal_PF)
                      + "at bus: " + str(new_bus))
        else:
            max_valid_p = min_p_to_check + (P_step * final_it)
            if verbose or debug:
                print("\nbiggest working P in bus " + str(new_bus) + " is " + str(max_valid_p) + "MW"
                      + " with PF of: " + str(minimal_PF))

    # Setting all back to default case
    if verbose:
        print("\nSetting everything back to normal")

    if not last_is_origin:  # if not already in origin place, moving to there
        error_code = psspy.movebrn(origin_bus, new_to_bus, new_id_brn, origin_connection_bus, origin_id_brn)
        if error_code > 0:
            print("\ncan't move BRN back to place, error code is = " + str(error_code))

    update_gen_and_trans_together(origin_bus, str(origin_id), origin_P, origin_PF, origin_connection_bus, origin_id_brn)

    if mega_solving:
        seem_fnsl()

    if verbose:
        print("\ngen " + str(origin_id) + " is back at bus " + str(origin_bus))

    return output
